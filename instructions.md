Для того чтобы ИИ (например, Claude 3.5 Sonnet или GPT-4) написал для тебя качественный код этого пайплайна, тебе нужно давать ему **узкоспециализированные технические промпты**. Один огромный запрос «Напиши Джарвиса» приведет к галлюцинациям.

Разделим процесс на 4 этапа. Вот инструкции, которые ты должен отправить своему AI-кодеру.

---

### Этап 1: Скелет MCP-сервера (Rust + Tokio)
**Инструкция для AI:**
> "Напиши Rust-приложение с использованием библиотеки `mcp-sdk-rs` (или аналогичной для протокола Model Context Protocol). 
> 1. Используй `tokio` как async runtime.
> 2. Создай сервер, который слушает стандартный ввод/вывод (stdio).
> 3. Реализуй структуру `JarvisServer` с методами регистрации инструментов (tools).
> 4. Заглушки для инструментов: `get_screen_metadata` (возвращает список окон), `capture_screen` (возвращает base64 скриншота), `execute_click` (координаты x, y).
> 5. Используй `anyhow` для обработки ошибок. Программа должна компилироваться под Windows."

---

### Этап 2: Модуль зрения (Windows DXGI Desktop Duplication)
Это самая сложная часть — быстро тащить кадры из видеокарты 4060.
**Инструкция для AI:**
> "Напиши модуль на Rust с использованием `windows-rs` для захвата экрана через **DXGI Desktop Duplication API**.
> 1. Настрой инициализацию `ID3D11Device` и `IDXGIOutputDuplication`.
> 2. Реализуй функцию `capture_frame()`, которая захватывает текущий кадр из GPU, копирует его в CPU-доступную текстуру и возвращает объект `image::DynamicImage`.
> 3. Добавь оптимизацию: если экран не изменился (результат `AcquireNextFrame` — Timeout), возвращай предыдущий кадр.
> 4. Код должен быть безопасным (правильно обрабатывать `Release()` для COM-объектов через Drop или врапперы windows-rs)."

---

### Этап 3: Инспектор интерфейса (UI Automation)
Чтобы ИИ не гадал по пикселям, а знал, где кнопка.
**Инструкция для AI:**
> "Напиши модуль `UI Inspector` на Rust, используя `windows-rs` и интерфейс **IUIAutomation**.
> 1. Реализуй функцию `get_ui_tree()`, которая обходит все видимые окна.
> 2. Для каждого элемента нужно извлечь: `Name`, `LocalizedControlType`, `BoundingRectangle` и `AutomationId`.
> 3. Результат должен сериализоваться в компактный JSON. 
> 4. Важно: ограничь глубину обхода (не более 5 уровней), чтобы не перегружать контекст модели данными. Сфокусируйся на интерактивных элементах (кнопки, поля ввода, списки)."

---

### Этап 4: Модуль исполнения (Input Simulation)
**Инструкция для AI:**
> "Напиши модуль `Executor` на Rust для эмуляции действий пользователя.
> 1. Используй WinAPI (`SendInput`) через `windows-rs` для перемещения курсора, кликов левой/правой кнопкой мыши и ввода текста.
> 2. Реализуй функцию `smooth_move(x, y)`, которая плавно перемещает курсор (опционально для обхода защиты от ботов, если нужно).
> 3. Добавь функцию `press_key_combo(modifiers, key)`, чтобы ИИ мог нажимать Alt+Tab, Win+D и т.д.
> 4. Интегрируй это с MCP-инструментами, созданными на Этапе 1."

---

### Общий "Системный Промпт" для твоего AI-кодера:
Перед началом работы отправь ему этот контекст:
> "Ты — эксперт по системному программированию на Rust и Windows API. Мы строим AI-агента (Jarvis), который управляет компьютером через второй монитор (Virtual Display). 
> **Стек:** Rust, windows-rs, MCP protocol, DXGI для Vision, UI Automation для анализа окон. 
> **Железо:** RTX 4060, используй возможности GPU там, где это ускоряет захват видео. 
> **Архитектура:** Агент работает как MCP-сервер, который подключается к Open WebUI.
> Пиши код максимально производительным, избегай лишних аллокаций памяти в цикле захвата экрана. Используй типизацию `windows-rs` строго."

---

### Почему это сработает?
1.  **Разделение ответственности:** Каждая часть кода независима. Если DXGI модуль упадет, ты сможешь отладить его отдельно.
2.  **Экономия VRAM:** Ты не просишь ИИ писать "нейронку для распознавания кнопок". Ты просишь его вытащить данные из **UI Automation API**, что потребляет 0.01% ресурсов по сравнению с компьютерным зрением.
3.  **MCP Ready:** Так как ты сразу закладываешь структуру MCP, Open WebUI подцепит твой Rust-сервер как родной "плагин" сразу после компиляции.

**С чего начнешь?** Рекомендую начать с **Этапа 1**, чтобы получить рабочий каркас, который можно просто запустить и увидеть в логах, что ИИ "услышал" команду.